{
  "name": "mattisg.configloader",
  "version": "0.2.0-alpha.2",
  "description": "A configuration loader focused on handling overrides cascades.",
  "keywords": [
    "configuration",
    "config",
    "setup",
    "defaults",
    "options",
    "init",
    "initialization"
  ],
  "homepage": "https://github.com/MattiSG/Node-ConfigLoader#README",
  "bugs": {
    "url": "https://github.com/MattiSG/Node-ConfigLoader/issues"
  },
  "author": {
    "name": "Matti Schneider",
    "email": "hi@mattischneider.fr",
    "url": "http://mattischneider.fr"
  },
  "files": [
    "README.md",
    "src"
  ],
  "main": "src/ConfigLoader.js",
  "directories": {
    "lib": "./src"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/MattiSG/Node-ConfigLoader.git"
  },
  "engines": {
    "node": ">=0.6"
  },
  "dependencies": {
    "mootools": "1.4"
  },
  "devDependencies": {
    "mocha": ">= 1.8",
    "istanbul": "0.1",
    "jsdoc": "3.2"
  },
  "scripts": {
    "test": "istanbul test _mocha",
    "doc": "jsdoc --private src --destination doc"
  },
  "readme": "ConfigLoader\n============\n\nA configuration loader for Node that “just works”, focused on handling overrides cascades.\n\nSpecificities\n-------------\n\n### Paths ###\n\nThere are already tons of config loaders for Node, but I couldn't find any that used the following algorithm:\n\n1. Start looking in the given directory (default to `cwd`), all the way up to another directory (default to user’s `$HOME`).\n2. Look in `$HOME/.<appname>/` (user config).\n3. Look in app defaults, (executable root, equivalent to `dirname($0)`).\n\nThe above gives the order of priority between properties: app defaults are of course overridden by the more specific directories.\n\n### Formats ###\n\nMany formats can be used, and are determined in a fuzzy manner (i.e. you don't have to expect your user to define config files in any specific format, as long as one version is readable it will be loaded). You can add any format you want at runtime.\n\nCurrently, JSON and CommonJS-style Javascript (i.e. a hash as `module.exports`) are supported out-of-the-box.\n\nUsage\n-----\n\n\tvar ConfigLoader = require('mattisg.configloader');\n\tvar loader = new ConfigLoader();\t// options can be passed as a hash, see beneath\n\tvar config = loader.load('config');\t// pass the name of the file to be looked up. It can include an extension if you want to enforce a specific format\n\n### Options ###\n\nOptions can be passed when initializing a ConfigLoader, as a hash:\n\n\tvar loader = new ConfigLoader({\n\t\toption: value,\n\t\t…\n\t});\n\nYou can also apply those options later, by calling `setOptions({ option: value, … })` on the ConfigLoader instance.\n\n#### `from` and `to` ####\n\nBy default, the ConfigLoader’s first pass will look for files from the current working directory (think `pwd`) all the way up to `~`. You can restrict this navigation algorithm to whichever subset you want, or redefine it entirely, with the `from` and `to` options.\n\nExample:\n\n\t// in /usr/toto/dev/toto.js\n\tnew ConfigLoader({\n\t\tfrom: __dirname + '/config/host'\n\t\tto:   __dirname\n\t}).load('config')\n\nThe above will load data from, in precedence order:\n\n1. `/usr/toto/dev/config/host/config.*`\n2. `/usr/toto/dev/config/config.*`\n3. `/usr/toto/dev/config.*`\n\n…plus the standard `~/.<app_name>/config.*`.\n\n#### `user` and `appName` ####\n\nThe above `<app_name>` defaults to the name of the running script. For example, if your application is executed by `node toto.js`, `<app_name>` will be `toto`, giving a default user preference folder of `~/.toto`.\n\nYou can override this heuristic with the `appName` option.\n\n\t// in /usr/toto/dev/toto.js\n\tnew ConfigLoader({\n\t\tappName: 'yogurt'\n\t}).load('config')\n\nAfter the usual `/usr/toto/dev/config.*` and `/usr/toto/config.*` (see above), `/usr/toto/.yogurt/config.*` will be looked up.\n\nYou can also override the `~` in `~/.<app_name>` for user-specific preferences, with the `user` option. For example:\n\n\tnew ConfigLoader({\n\t\tuser: process.env.HOME + '/Library/Preferences',\n\t\tappName: 'com.dairy.yogurt'\n\t}).load('config')\n\n…would give a much more OSX-like lookup, by looking in `~/Library/Preferences/com.dairy.yogurt/` for `config.*` files.\n\n#### `visitAlso` ####\n\nIf you need to load defaults from more unusual locations, or if your module may be executed from different binaries (thus making the “executable root” heuristic non-effective), you may specify default folders to visit with this option.\n\nYou may set either a single folder path as a String, or an array of folder paths, which will be visited in the given order. In all cases, they will be loaded _after_ the places defined by the standard algorithm.\n\n#### Programmatic `override` ####\n\nIf you want to ignore some values from the loaded configuration at runtime, simply use the `override` option. It can be thought of defaults, but in reverse: instead of being values to use if none other are specified, those will always be used, no matter what config files say.\n\nThis override can be global, or can be specific to each file if you intend to use the same ConfigLoader instance to load different config files.\n\nExample:\n\n\tnew ConfigLoader({\n\t\toverride: {\n\t\t\t'host': '127.0.0.1'\n\t\t}\n\t})\n\n…whether you `.load('config')` or `.load('database')`, all files will have their `host` value overridden. We can change this behavior with the following:\n\n\t\toverride: {\n\t\t\tconfig: {\n\t\t\t\t'host': '127.0.0.1:80'\t// in the hash returned by load('config')\n\t\t\t},\n\t\t\tdatabase: {\n\t\t\t\t'host': '127.0.0.1:3000'\t// in the hash returned by load('database')\n\t\t\t}\n\t\t}\n\n#### `observer` ####\n\nIf you ever feel the need to understand how the configuration is parsed to pinpoint the source of a specific value, you could pass a logging function as the `observer` option. Its value is a function, which will be called on each visited directory, with two parameters:\n\n1. The visited directory.\n2. The parsed data (all since the beginning, not only the new one from the given directory).\n\nEspecially useful for quick debugging with `observer: console.error`, but could be used with Winston loggers or any event-driven trigger.\n\n#### `transform` ####\n\nYou may want to support shortcuts in your config files, in order to make the specification simpler, while still supporting advanced overrides. The `transform` option is a function, which will be called each time some config data is about to be loaded, with two parameters:\n\n1. The about-to-be-loaded data.\n2. The already-stored data (all since the beginning).\n\nWhat will be stored at that step is **only** the return value from the provided function.\n\n**Example**:\n\nSupport an URL to be specified as either a string or an [URL object](http://nodejs.org/docs/v0.8.16/api/url.html), uniforming the type to an object, therefore allowing specific overrides:\n\n\tnew ConfigLoader({\n\t\ttransform: function objectifyUrl(data) {\n\t\t\tif (typeof data.url == 'string')\n\t\t\t\tdata.url = require('url').parse(data.url);\n\n\t\t\treturn data;\t// remember to return your results, otherwise nothing will be stored!\n\t\t}\n\t});\n\nThe above allows any configuration file to specify either a full URL as a string, or provide only parts of it (e.g. `{ url: { port: 3000 } }`), while ensuring the previously extracted values will be kept.\n\n#### Defaults ####\n\nDefault values should _not_ be set as options, but set in a config file distributed alongside the application, in order to make them easily editable and to support proper decoupling. Hence, there is no way to set default values from options.\n\nIf you see a correct use case for such an option, please open an issue.\n\n### Adding formats ###\n\n\t// let's add support for YAML\n\tConfigLoader.parsers['yaml'] = function(content) { return require('my-yaml-parser').parse(contents); }\n\n\tconfig = loader.load('config');\t// reload the same config as above, but YAML files will now be parsed too\n\nFuzzy matching warning\n----------------------\n\nIf several files in the same format are available at the same depth (i.e. you have `config.js` and `config.json` in the same folder), **the precedence is unspecified**. There is no way to know for sure whether values from the `.js` will override the ones from the `.json`, or if it will be the other way around. The only certain thing is that will take precedence for _all_ keys, i.e. the precedence is unspecified at file level, not at individual properties level.\n\nBeyond this overriding specificity, non-conflicting values will all be loaded.\n",
  "readmeFilename": "README.md",
  "_id": "mattisg.configloader@0.2.0-alpha.2",
  "dist": {
    "shasum": "6f0ee31e5ea1bb3b4a1bfcf77fe9596527d348fc",
    "tarball": "http://registry.npmjs.org/mattisg.configloader/-/mattisg.configloader-0.2.0-alpha.2.tgz"
  },
  "_from": "mattisg.configloader@0.2.0-alpha.2",
  "_npmVersion": "1.3.11",
  "_npmUser": {
    "name": "mattisg",
    "email": "hi@mattischneider.fr"
  },
  "maintainers": [
    {
      "name": "mattisg",
      "email": "hi@mattischneider.fr"
    }
  ],
  "_shasum": "6f0ee31e5ea1bb3b4a1bfcf77fe9596527d348fc",
  "_resolved": "http://registry.npmjs.org/mattisg.configloader/-/mattisg.configloader-0.2.0-alpha.2.tgz"
}
